from pydantic import BaseModel, create_model
from typing import Optional, List, Dict, Any, Type
from enum import Enum

from typing import Any, Optional

from pydantic import BaseModel, Field, create_model

TYPE_MAPPING: dict[str, type] = {
    "string": str,
    "integer": int,
    "number": float,
    "boolean": bool,
    "object": dict,
    "array": list,
    "null": type(None),
}

CONSTRAINT_MAPPING: dict[str, str] = {
    "minimum": "ge",
    "maximum": "le",
    "exclusiveMinimum": "gt",
    "exclusiveMaximum": "lt",
    "inclusiveMinimum": "ge",
    "inclusiveMaximum": "le",
    "minItems": "min_length",
    "maxItems": "max_length",
}


def get_field_params_from_field_schema(field_schema: dict) -> dict:
    """Gets Pydantic field parameters from a JSON schema field."""
    field_params = {}
    for constraint, constraint_value in CONSTRAINT_MAPPING.items():
        if constraint in field_schema:
            field_params[constraint_value] = field_schema[constraint]
    if "description" in field_schema:
        field_params["description"] = field_schema["description"]
    if "default" in field_schema:
        field_params["default"] = field_schema["default"]
    return field_params


def create_enum(enum_name: str, enum_values: list, globals_dict: dict) -> type[Enum]:
    """Dynamically create an Enum type and add it to the provided globals dict."""
    enum_type = Enum(enum_name, {str(v): v for v in enum_values})
    # Pydantic uses __module__ to determine where the type comes from.
    # Setting it to a known module (like the calling module via globals_dict['__name__'])
    # can help, but adding to globals is usually the most direct way for dynamic types.
    if "__name__" in globals_dict:
        enum_type.__module__ = globals_dict["__name__"]
    globals_dict[enum_name] = enum_type
    return enum_type


def create_model_from_schema(schema: dict, globals_dict: dict) -> type[BaseModel]:  # noqa: C901
    """Create Pydantic model from a JSON schema generated by `Model.model_json_schema()`."""
    models: dict[str, type[BaseModel]] = {}
    enums: dict[str, type[Enum]] = {}

    def resolve_field_type(
        field_schema_item: dict, field_name_context: str = ""
    ) -> type[Any]:
        """Resolves field type, including optional types, nullability, enums, and $refs."""
        nonlocal models, enums, schema, globals_dict

        if "$ref" in field_schema_item:
            model_reference = field_schema_item["$ref"].split("/")[-1]
            if model_reference in models:
                return models[model_reference]
            if model_reference in enums:
                return enums[model_reference]

            defs = schema.get("$defs", {})
            if model_reference in defs:
                def_schema_ref = defs[model_reference]
                if def_schema_ref.get("enum") and model_reference not in enums:
                    enums[model_reference] = create_enum(
                        model_reference, def_schema_ref["enum"], globals_dict
                    )
                    return enums[model_reference]
                if (
                    def_schema_ref.get("type") == "object"
                    and model_reference not in models
                ):
                    # Eagerly create the referenced model if it's an object
                    def_fields = {}
                    for prop_name, prop_schema in def_schema_ref.get(
                        "properties", {}
                    ).items():
                        field_type = resolve_field_type(
                            field_schema_item=prop_schema, field_name_context=prop_name
                        )
                        field_params = get_field_params_from_field_schema(
                            field_schema=prop_schema
                        )
                        def_fields[prop_name] = (field_type, Field(**field_params))
                    model = create_model(
                        model_reference,
                        **def_fields,
                        __doc__=def_schema_ref.get("description", ""),
                    )
                    models[model_reference] = model
                    globals_dict[model_reference] = model
                    return model
                # If it's not an object or enum, fallback to string name (should be rare)
            # Fallback: return string name for forward ref (should be rare now)
            return model_reference

        if "enum" in field_schema_item:  # Inline enum definition
            explicit_title = field_schema_item.get("title")
            if explicit_title:
                base_name = explicit_title
            elif field_name_context:
                base_name = field_name_context.capitalize() + "Enum"
            else:
                base_name = "AnonymousEnum"  # Fallback for truly anonymous inline enum

            enum_name_candidate = base_name
            counter = 0
            while enum_name_candidate in enums or enum_name_candidate in globals_dict:
                counter += 1
                enum_name_candidate = f"{base_name}{counter}"

            final_enum_name = enum_name_candidate
            # enums dict is for local tracking during this creation process
            enums[final_enum_name] = create_enum(
                final_enum_name, field_schema_item["enum"], globals_dict
            )
            return enums[final_enum_name]

        if "anyOf" in field_schema_item:
            types = []
            has_none = False
            for sub_schema in field_schema_item["anyOf"]:
                if sub_schema.get("type") == "null":
                    has_none = True
                else:
                    types.append(
                        resolve_field_type(sub_schema, field_name_context)
                    )  # Recursive call

            if not types:  # Only "null" was present or empty anyOf
                return type(None)

            # Filter out type(None) if Optional is used
            actual_types = [t for t in types if t is not type(None)]

            if len(actual_types) == 1:
                resolved_type = actual_types[0]
            elif actual_types:
                # Pydantic uses Union for anyOf with multiple types
                # Ensure Union is imported from typing
                from typing import Union as TypingUnion

                resolved_type = TypingUnion[tuple(actual_types)]  # type: ignore
            else:  # Only type(None) was effectively present in types after filtering
                return type(None)

            return Optional[resolved_type] if has_none else resolved_type

        field_type_str = field_schema_item.get("type")
        py_type = TYPE_MAPPING.get(field_type_str, Any)

        if py_type is list and "items" in field_schema_item:
            item_schema = field_schema_item["items"]
            # Pass a modified context name for items, e.g. "MyFieldItem"
            item_py_type = resolve_field_type(item_schema, field_name_context + "Item")
            return List[item_py_type]  # type: ignore

        if py_type is dict and "additionalProperties" in field_schema_item:
            # Assuming additionalProperties defines the type of values in the dict
            # JSON schema for object with unspecified keys uses additionalProperties for value type
            value_schema = field_schema_item["additionalProperties"]
            if isinstance(value_schema, dict):  # If additionalProperties is a schema
                # Pass a modified context name for values, e.g. "MyFieldValue"
                value_py_type = resolve_field_type(
                    value_schema, field_name_context + "Value"
                )
                return Dict[str, value_py_type]  # type: ignore
            elif value_schema is True:  # Allows any type for values
                return Dict[str, Any]
            else:  # additionalProperties is false, no extra props allowed (empty dict essentially)
                return Dict[str, Any]  # Or raise error / use a more restrictive type

        # Handle simple object type if not using additionalProperties for value types
        # This typically means a generic dict without specified value types from schema
        if (
            py_type is dict
            and "properties" not in field_schema_item
            and "additionalProperties" not in field_schema_item
        ):
            return Dict[str, Any]

        return py_type

    # First, create models and enums for definitions ($defs)
    # This ensures they are in globals_dict before being referenced by main model or other defs.
    definitions = schema.get("$defs", {})
    for def_name, def_schema in definitions.items():
        if def_schema.get("type") == "object":  # It's a Pydantic model definition
            if (
                def_name not in models
            ):  # Avoid reprocessing if already created by a forward ref
                def_fields = {}
                for prop_name, prop_schema in def_schema.get("properties", {}).items():
                    field_type = resolve_field_type(
                        field_schema_item=prop_schema, field_name_context=prop_name
                    )
                    field_params = get_field_params_from_field_schema(
                        field_schema=prop_schema
                    )
                    def_fields[prop_name] = (field_type, Field(**field_params))

                model = create_model(
                    def_name, **def_fields, __doc__=def_schema.get("description", "")
                )
                models[def_name] = model
                globals_dict[def_name] = (
                    model  # Crucial for Pydantic to find it by name
                )

        elif def_schema.get("enum"):  # It's an Enum definition in $defs
            if def_name not in enums:
                # create_enum adds it to globals_dict
                enums[def_name] = create_enum(
                    def_name, def_schema["enum"], globals_dict
                )

    # Now, create the main model, resolving references
    main_fields = {}
    for field_name, field_schema_item in schema.get("properties", {}).items():
        field_type = resolve_field_type(
            field_schema_item=field_schema_item, field_name_context=field_name
        )
        field_params = get_field_params_from_field_schema(
            field_schema=field_schema_item
        )
        main_fields[field_name] = (field_type, Field(**field_params))

    # Use the title directly from the schema for the main model
    final_main_model_title = schema.get("title", "MainModel")

    main_model = create_model(
        final_main_model_title, **main_fields, __doc__=schema.get("description", "")
    )
    globals_dict[final_main_model_title] = (
        main_model  # Add/update main model in globals
    )

    # After all models are created and placed in globals_dict,
    # rebuild them to resolve any forward references.

    # Collect all dynamically created Pydantic model classes
    all_pydantic_model_classes_to_rebuild = []
    # Add models from $defs (stored in the 'models' dictionary)
    for model_class in models.values():
        if isinstance(model_class, type) and issubclass(model_class, BaseModel):
            all_pydantic_model_classes_to_rebuild.append(model_class)

    # Add the main model itself
    if isinstance(main_model, type) and issubclass(main_model, BaseModel):
        # Avoid adding main_model if it's already in the list by reference
        # (e.g., if main_model was one of the models from $defs, though unlikely for the root model)
        is_main_model_already_in_list = any(
            mc is main_model for mc in all_pydantic_model_classes_to_rebuild
        )
        if not is_main_model_already_in_list:
            all_pydantic_model_classes_to_rebuild.append(main_model)

    # Call model_rebuild() on each collected Pydantic model class.
    # This helps Pydantic resolve all forward references using the types now available
    # in globals_dict.
    for p_model_class in all_pydantic_model_classes_to_rebuild:
        try:
            p_model_class.model_rebuild()
        except Exception as e:
            # Log a warning if a model fails to rebuild, as this might indicate
            # an unresolvable type or a deeper schema issue.
            print(
                f"Warning: Error during model_rebuild for {p_model_class.__name__}: {e}"
            )
            # Depending on requirements, one might choose to raise an error here.

    return main_model



def render_model(model: Any, indent: int = 0) -> str:
    spacer = "  " * indent

    def format_entry(key: str, value: Any, level: int) -> str:
        prefix = "  " * level + f"{key}:"

        if isinstance(value, BaseModel) or isinstance(value, dict):
            return f"{prefix}\n" + render_model(value, level + 1)

        elif isinstance(value, list):
            if not value:
                return f"{prefix} []"
            entries = []
            for idx, item in enumerate(value, 1):
                if isinstance(item, BaseModel) or isinstance(item, dict):
                    item_str = render_model(item, level + 2)
                    entries.append(f"{'  ' * (level + 1)}{idx}.\n{item_str}")
                else:
                    entries.append(f"{'  ' * (level + 1)}{idx}. {item}")
            return f"{prefix}\n" + "\n".join(entries)

        else:
            return f"{prefix} {value}"

    lines = []
    if isinstance(model, BaseModel):
        data = model.__dict__
    elif isinstance(model, dict):
        data = model
    else:
        raise TypeError(f"Expected BaseModel or dict, got {type(model)}")

    for field_name, value in data.items():
        if value is not None:
            lines.append(format_entry(field_name, value, indent))

    return "\n".join(lines)
