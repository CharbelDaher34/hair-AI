#!/usr/bin/env python3
"""
Streamlit interface for visualizing Elasticsearch query results.
Reads from JSON file generated by elasticsearch_model_generator.py
"""

import json
import streamlit as st
from pathlib import Path
from datetime import datetime


def LoadJsonData(filename: str = "example_queries.json") -> list:
    """Load query data from JSON file."""
    file_path = Path(filename)
    if not file_path.exists():
        return []
    
    try:
        return json.loads(file_path.read_text())
    except (json.JSONDecodeError, FileNotFoundError):
        return []


def ProcessLiveQuery(query: str) -> dict:
    """Process a live query using the ElasticsearchModelGenerator."""
    try:
        # Import here to avoid circular imports
        from elasticsearch_model_generator import ElasticsearchModelGenerator
        
        client = ElasticsearchModelGenerator(
            index_name="user_transactions",
            category_fields=[
                "card_kind",
                "card_type", 
                "transaction.receiver.category_type",
                "transaction.receiver.location",
                "transaction.type",
                "transaction.currency"
            ],
            fields_to_ignore=["user_id", "card_number"],
        )
        
        result = client.QueryFromNaturalLanguage(query, execute=False)
        return {
            "input": query,
            "filter": result["extracted_filters"],
            "elastic_query": result["elasticsearch_queries"],
            "status": "success"
        }
    except Exception as e:
        return {
            "input": query,
            "filter": None,
            "elastic_query": None,
            "status": "error",
            "error": str(e)
        }


def DisplayQueryCard(query_data: dict, index: int):
    """Display a single query result in an expandable card."""
    # Determine status based on presence of required fields
    has_filter = query_data.get("filter") is not None
    has_elastic_query = query_data.get("elastic_query") is not None
    status = "success" if has_filter and has_elastic_query else "error"
    
    # Create status indicator
    status_icon = "✅" if status == "success" else "❌"
    status_color = "green" if status == "success" else "red"
    
    with st.expander(f"{status_icon} Query {index + 1}: {query_data['input'][:60]}..."):
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.markdown(f"**Query:** {query_data['input']}")
        with col2:
            st.markdown(f"**Status:** :{status_color}[{status.upper()}]")
        
        if status == "success":
            # Show filters
            st.subheader("🔍 Extracted Filters")
            if query_data.get("filter"):
                st.json(query_data["filter"])
            else:
                st.info("No filters extracted")
            
            # Show elastic queries
            st.subheader("🔧 Elasticsearch Queries")
            if query_data.get("elastic_query"):
                for i, eq in enumerate(query_data["elastic_query"]):
                    st.markdown(f"**Query {i + 1}:**")
                    st.json(eq)
            else:
                st.info("No Elasticsearch queries generated")
                
        else:
            # Show error
            st.error(f"Error: {query_data.get('error', 'Missing filter or elastic_query data')}")


def DisplayLiveQueryResult(query_data: dict):
    """Display a live query result with better formatting."""
    status = query_data.get("status", "error")
    status_icon = "✅" if status == "success" else "❌"
    status_color = "green" if status == "success" else "red"
    
    st.markdown(f"### {status_icon} Query Result")
    st.markdown(f"**Status:** :{status_color}[{status.upper()}]")
    
    if status == "success":
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("🔍 Extracted Filters")
            if query_data.get("filter"):
                st.json(query_data["filter"])
            else:
                st.info("No filters extracted")
        
        with col2:
            st.subheader("🔧 Elasticsearch Queries")
            if query_data.get("elastic_query"):
                for i, eq in enumerate(query_data["elastic_query"]):
                    st.markdown(f"**Query {i + 1}:**")
                    st.json(eq)
            else:
                st.info("No Elasticsearch queries generated")
    else:
        st.error(f"Error: {query_data.get('error', 'Unknown error')}")


def FilterData(data: list, status_filter: str, search_term: str) -> list:
    """Filter data based on status and search term."""
    filtered = data
    
    # Filter by status
    if status_filter != "All":
        filtered = [
            item for item in filtered 
            if (lambda item: "success" if (item.get("filter") is not None and item.get("elastic_query") is not None) else "error")(item) == status_filter.lower()
        ]
    
    # Filter by search term
    if search_term:
        filtered = [
            item for item in filtered 
            if search_term.lower() in item.get("input", "").lower()
        ]
    
    return filtered


def RunStreamlitViewer():
    """Main Streamlit interface for viewing query results."""
    st.set_page_config(
        page_title="Elasticsearch Query Viewer",
        page_icon="📊",
        layout="wide"
    )
    
    st.title("📊 Elasticsearch Query Results Viewer")
    st.markdown("View and analyze results from processed natural language queries")
    
    # Create tabs for different sections
    tab1, tab2, tab3 = st.tabs(["🔍 Live Query", "📋 Saved Queries", "📋 Model Info"])
    
    with tab1:
        st.header("🔍 Live Query Processing")
        st.markdown("Enter a natural language query to see how it's processed in real-time")
        
        # Query input
        query_input = st.text_area(
            "Enter your query:",
            placeholder="e.g., 'Show me all transactions from last month' or 'How much did I spend on food?'",
            height=100
        )
        
        col1, col2, col3 = st.columns([1, 1, 4])
        
        with col1:
            process_button = st.button("🚀 Process Query", type="primary")
        
        with col2:
            if st.button("💾 Save to File"):
                if query_input.strip():
                    if 'live_result' in st.session_state:
                        # Save the processed query to the JSON file
                        file_path = Path("example_queries.json")
                        existing_data = []
                        if file_path.exists():
                            try:
                                existing_data = json.loads(file_path.read_text())
                            except (json.JSONDecodeError, FileNotFoundError):
                                existing_data = []
                        
                        # Add timestamp to the result
                        result_to_save = st.session_state.live_result.copy()
                        result_to_save["timestamp"] = datetime.now().isoformat()
                        
                        existing_data.append(result_to_save)
                        file_path.write_text(json.dumps(existing_data, indent=2))
                        st.success("Query saved to example_queries.json!")
                    else:
                        st.warning("Please process a query first before saving")
                else:
                    st.warning("Please enter a query first")
        
        # Process the query
        if process_button and query_input.strip():
            with st.spinner("Processing query..."):
                result = ProcessLiveQuery(query_input.strip())
                st.session_state.live_result = result
        
        # Display result if available
        if 'live_result' in st.session_state:
            st.divider()
            DisplayLiveQueryResult(st.session_state.live_result)
        
        # Example queries
        st.divider()
        st.subheader("💡 Example Queries")
        example_queries = [
            "Show me all transactions from last month",
            "How much did I spend on food?",
            "What are my recent deposits?",
            "Transactions over $100 in December",
            "Compare hotel spending with restaurant spending"
        ]
        
        cols = st.columns(len(example_queries))
        for i, example in enumerate(example_queries):
            with cols[i]:
                if st.button(f"Try: {example[:20]}...", key=f"example_{i}"):
                    st.session_state.example_query = example
                    st.rerun()
        
        # Auto-fill from example if selected
        if 'example_query' in st.session_state:
            st.text_area(
                "Selected example query:",
                value=st.session_state.example_query,
                height=60,
                key="example_display"
            )
            if st.button("🚀 Process Example", type="primary"):
                with st.spinner("Processing example query..."):
                    result = ProcessLiveQuery(st.session_state.example_query)
                    st.session_state.live_result = result
                    st.rerun()
    
    with tab2:
        st.header("📋 Saved Query Results")
        
        # Sidebar controls
        with st.sidebar:
            st.header("Controls")
            
            # File selection
            json_file = st.text_input("JSON File:", value="example_queries.json")
            
            # Refresh button
            if st.button("🔄 Refresh Data"):
                st.rerun()
            
            # Load data
            data = LoadJsonData(json_file)
            
            if not data:
                st.warning(f"No data found in {json_file}")
                st.info("Run elasticsearch_model_generator.py to generate data")
                return
            
            st.success(f"Loaded {len(data)} queries")
            
            # Filters
            st.subheader("Filters")
            
            # Status filter
            status_options = ["All", "success", "error"]
            status_filter = st.selectbox("Status:", status_options)
            
            # Search filter
            search_term = st.text_input("Search in queries:")
            
            # Apply filters
            filtered_data = FilterData(data, status_filter, search_term)
            
            st.info(f"Showing {len(filtered_data)} of {len(data)} queries")
        
        # Main content
        if not data:
            st.info("No data to display. Run the elasticsearch_model_generator.py script to generate query data.")
            return
        
        # Query results
        if not filtered_data:
            st.info("No queries match the current filters.")
            return
        
        # Display queries
        for i, query_data in enumerate(filtered_data):
            DisplayQueryCard(query_data, i)
    
    with tab3:
        st.header("📋 Model Information")
        st.markdown("Understanding the data schema and available fields for querying")
        
        # Load model info
        try:
            from elasticsearch_model_generator import ElasticsearchModelGenerator
            
            client = ElasticsearchModelGenerator(
                index_name="user_transactions",
                category_fields=[
                    "card_kind",
                    "card_type", 
                    "transaction.receiver.category_type",
                    "transaction.receiver.location",
                    "transaction.type",
                    "transaction.currency"
                ],
                fields_to_ignore=["user_id", "card_number"],
            )
            
            # Add debug section
            with st.expander("🔧 Debug Information", expanded=False):
                st.markdown("**Debug category field processing**")
                
                if st.button("Run Debug Check"):
                    with st.spinner("Running debug check..."):
                        debug_info = client.debug_category_fields()
                        
                        st.subheader("Configured Category Fields")
                        st.json(debug_info["configured_category_fields"])
                        
                        st.subheader("Processing Results")
                        for field, info in debug_info["processed_fields"].items():
                            col1, col2 = st.columns([1, 2])
                            with col1:
                                st.markdown(f"**{field}**")
                                st.markdown(f"Values found: {info['distinct_values_found']}")
                            with col2:
                                if info['distinct_values_found'] > 0:
                                    st.markdown(f"Field path: `{info['field_path_used']}`")
                                    st.markdown(f"Sample values: {info['sample_values']}")
                                else:
                                    st.error("No values found - field might not exist or have no data")
                        
                        if debug_info["errors"]:
                            st.subheader("❌ Errors")
                            for error in debug_info["errors"]:
                                st.error(error)
                        
                        st.subheader("Available Fields in Index")
                        available_fields = debug_info.get("available_fields", [])
                        if available_fields:
                            # Show fields that might be category fields
                            potential_category_fields = [f for f in available_fields if any(cat in f for cat in ["type", "category", "currency", "location", "kind"])]
                            if potential_category_fields:
                                st.markdown("**Potential category fields:**")
                                for field in potential_category_fields:
                                    st.markdown(f"• `{field}`")
                            
                            # Show all fields in a searchable format
                            search_available = st.text_input("Search available fields:", key="search_available")
                            filtered_available = [f for f in available_fields if not search_available or search_available.lower() in f.lower()]
                            st.markdown(f"**All available fields ({len(filtered_available)}/{len(available_fields)}):**")
                            for field in filtered_available[:20]:  # Show first 20
                                st.markdown(f"• `{field}`")
                            if len(filtered_available) > 20:
                                st.markdown(f"*... and {len(filtered_available) - 20} more*")
            
            with st.spinner("Loading model information..."):
                model_info = client.get_model_info()
                
            # Display model summary
            st.subheader("📊 Schema Overview")
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("Total Fields", len(model_info))
            
            with col2:
                enum_fields = sum(1 for field in model_info.values() if field.get("type") == "enum")
                st.metric("Enum Fields", enum_fields)
            
            with col3:
                array_fields = sum(1 for field in model_info.values() if field.get("type") == "array")
                st.metric("Array Fields", array_fields)
            
            # Field type distribution
            st.subheader("📈 Field Type Distribution")
            type_counts = {}
            for field_info in model_info.values():
                field_type = field_info.get("type", "unknown")
                type_counts[field_type] = type_counts.get(field_type, 0) + 1
            
            # Display as columns
            type_cols = st.columns(len(type_counts))
            for i, (field_type, count) in enumerate(type_counts.items()):
                with type_cols[i]:
                    st.metric(field_type.title(), count)
            
            # Searchable field list
            st.subheader("🔍 Field Explorer")
            
            # Search functionality
            search_field = st.text_input("Search fields:", placeholder="e.g., 'transaction', 'amount', 'category'")
            
            # Filter fields based on search
            filtered_fields = {}
            for field_name, field_info in model_info.items():
                if not search_field or search_field.lower() in field_name.lower():
                    filtered_fields[field_name] = field_info
            
            if search_field and not filtered_fields:
                st.info(f"No fields found matching '{search_field}'")
            
            # Display fields in expandable sections
            st.markdown(f"**Showing {len(filtered_fields)} of {len(model_info)} fields**")
            
            # Group fields by type for better organization
            field_groups = {}
            for field_name, field_info in filtered_fields.items():
                field_type = field_info.get("type", "unknown")
                if field_type not in field_groups:
                    field_groups[field_type] = []
                field_groups[field_type].append((field_name, field_info))
            
            # Display each group
            for field_type, fields in field_groups.items():
                with st.expander(f"{field_type.title()} Fields ({len(fields)})", expanded=field_type == "enum"):
                    for field_name, field_info in sorted(fields):
                        col1, col2 = st.columns([2, 3])
                        
                        with col1:
                            st.markdown(f"**`{field_name}`**")
                            st.markdown(f"*Type: {field_info.get('type', 'unknown')}*")
                            
                            if field_info.get("is_array_item"):
                                st.markdown("*Part of array structure*")
                        
                        with col2:
                            if field_info.get("type") == "enum":
                                values = field_info.get("values", [])
                                if values:
                                    st.markdown("**Available values:**")
                                    # Display values in a more compact format
                                    if len(values) <= 10:
                                        for value in values:
                                            st.markdown(f"• `{value}`")
                                    else:
                                        # Show first 8 values and indicate more
                                        for value in values[:8]:
                                            st.markdown(f"• `{value}`")
                                        st.markdown(f"*... and {len(values) - 8} more values*")
                                else:
                                    st.markdown("*No enum values available*")
                            
                            elif field_info.get("type") == "array":
                                item_type = field_info.get("item_type", "unknown")
                                st.markdown(f"**Array of:** {item_type}")
                                
                                if field_info.get("values"):
                                    st.markdown("**Possible values:**")
                                    values = field_info.get("values", [])
                                    if len(values) <= 5:
                                        for value in values:
                                            st.markdown(f"• `{value}`")
                                    else:
                                        for value in values[:5]:
                                            st.markdown(f"• `{value}`")
                                        st.markdown(f"*... and {len(values) - 5} more*")
                            
                            else:
                                # For basic types, show example usage
                                examples = {
                                    "string": "e.g., 'restaurant', 'online'",
                                    "number": "e.g., 100, 250.50",
                                    "boolean": "e.g., true, false",
                                    "date": "e.g., '2024-01-01'"
                                }
                                if field_info.get("type") in examples:
                                    st.markdown(f"**Example:** {examples[field_info.get('type')]}")
                        
                        st.divider()
            
            # Query examples section
            st.subheader("💡 Query Examples by Field Type")
            
            example_queries = {
                "Enum Fields": [
                    "Show me all GOLD card transactions",
                    "What purchases did I make at restaurants?",
                    "Transactions in New York"
                ],
                "Number Fields": [
                    "Transactions over $100",
                    "Spending less than $50",
                    "Amount between $20 and $200"
                ],
                "Date Fields": [
                    "Transactions from last month",
                    "Spending in January 2024",
                    "Recent deposits"
                ],
                "String Fields": [
                    "Transactions at Starbucks",
                    "Purchases containing 'coffee'",
                    "Online transactions"
                ]
            }
            
            for category, queries in example_queries.items():
                with st.expander(f"{category} Examples"):
                    for query in queries:
                        col1, col2 = st.columns([3, 1])
                        with col1:
                            st.markdown(f"• {query}")
                        with col2:
                            if st.button("Try", key=f"try_{query}"):
                                st.session_state.example_query = query
                                st.switch_page("🔍 Live Query")
            
        except Exception as e:
            st.error(f"Error loading model information: {str(e)}")
            st.info("Make sure the elasticsearch_model_generator.py file is accessible and the Elasticsearch connection is working.")


if __name__ == "__main__":
    RunStreamlitViewer() 
    

